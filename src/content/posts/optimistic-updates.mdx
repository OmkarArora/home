---
title: "Optimistic Updates: Building Instant, Responsive UIs"
publishedAt: "2025-12-16"
summary: "Learn how optimistic updates can transform your user experience by making UIs feel instant and responsive. Discover implementation patterns, error handling strategies, and best practices for React applications."
keywords: "optimistic updates, react, ux, user experience, state management, react query, tanstack query, performance, ui patterns, frontend development"
---

When you tap "Like" on a post and it turns blue instantly, you just experienced an optimistic update.

Instead of waiting for the server to confirm that your action succeeded, the UI **assumes success**, updates immediately, and quietly fixes things in the background if something goes wrong. Done well, this makes your app feel instant and delightful—even on slow networks.

In this post, we'll explore what optimistic updates are, when to use them, how to implement them in React (including React Query and React 19's `useOptimistic`), and how to avoid the most common pitfalls.

## What Are Optimistic Updates?

**Optimistic updates** are a UI pattern where you:

1. **Update the UI immediately** in response to a user action.
2. **Send the request to the server** in the background.
3. **Rollback or adjust the UI** if the server responds with an error.

Instead of:

- user clicks → wait for response → then update UI

You do:

- user clicks → update UI immediately → wait for response → keep or rollback

### Key Characteristics

- **Immediate feedback**: The UI reacts instantly to user input.
- **Assumes success**: You design for the _common_ case where the request succeeds.
- **Rollback mechanism**: You keep enough information to restore the previous state if needed.

This pattern is especially powerful for list-based UIs, toggles, and social interactions, where a short delay feels worse than a rare correction.

## Why Optimistic Updates Matter

### User Experience Benefits

- **Perceived performance**: Users feel like your app is fast, even if the network isn't.
- **Reduced latency pain**: Actions feel local instead of "remote".
- **App-like feel**: Web apps start to feel like native apps.

### Business & Product Impact

- **Higher engagement**: Users are more willing to interact when the UI feels snappy.
- **Lower abandonment**: Less waiting means fewer "did it even work?" moments.
- **Better first impressions**: Perceived speed is often more important than raw benchmarks.

### Technical Benefits

- **Hides network variance**: UI remains smooth even when the backend isn't.
- **Pairs well with caching**: Optimistic updates on top of a good cache make apps feel real-time.

## When to Use (and Not Use) Optimistic Updates

### Great Use Cases

- **Social interactions**: likes, bookmarks, follows, upvotes.
- **Simple toggles**: feature flags, preferences, favorite buttons.
- **CRUD on non-critical data**:
  - Creating / editing / deleting todos, notes, comments.
  - Reordering items in a list.
- **Local-first UX**: Data is primarily manipulated on the client and synced later.

### Be Careful or Avoid When

- **Money is involved**: payments, refunds, wallet balances.
- **Irreversible or destructive actions**: permanent deletions, security-sensitive changes.
- **Heavy validation is required**: operations that often fail server-side.
- **Conflict-prone data**: complex shared documents without conflict resolution.

### Quick Decision Checklist

Ask yourself:

- "If this fails, can I **safely rollback** without confusing the user?"
- "Is this operation **highly likely to succeed**?"
- "Is the **UI jarring** if we occasionally undo an action?"

If the answers are mostly "yes", optimistic updates are a strong candidate.

## Basic Implementation Pattern (React `useState`)

Let's start with a minimal optimistic "favorite" toggle.

```tsx showLineNumbers
import { useState } from "react";

async function fakeToggleFavoriteApi(nextValue: boolean) {
	// Simulate network latency
	await new Promise((resolve) => setTimeout(resolve, 800));

	// Simulate occasional failure
	if (Math.random() < 0.2) {
		throw new Error("Failed to update favorite. Please try again.");
	}

	return nextValue;
}

export function BasicOptimisticFavorite() {
	const [isFavorite, setIsFavorite] = useState(false);
	const [isPending, setIsPending] = useState(false);
	const [error, setError] = useState<string | null>(null);

	async function handleToggle() {
		if (isPending) return;

		setError(null);

		// 1. Snapshot previous value
		const previous = isFavorite;

		// 2. Optimistically update UI
		const next = !isFavorite;
		setIsFavorite(next);
		setIsPending(true);

		try {
			// 3. Fire request in background
			await fakeToggleFavoriteApi(next);
		} catch (err) {
			// 4. Rollback on failure
			setIsFavorite(previous);
			setError((err as Error).message);
		} finally {
			setIsPending(false);
		}
	}

	return (
		<div className="inline-flex flex-col items-start gap-2 text-sm">
			<button
				onClick={handleToggle}
				disabled={isPending}
				className={`rounded-full border px-3 py-1 text-xs md:text-sm transition-colors ${
					isFavorite
						? "bg-green-600 text-white border-green-700"
						: "bg-background text-foreground hover:bg-muted"
				}`}
			>
				{isFavorite ? "★ Favorited" : "☆ Add to favorites"}
				{isPending && <span className="ml-2 opacity-80">Saving…</span>}
			</button>
			{error && <p className="text-xs text-red-500">{error}</p>}
		</div>
	);
}
```

This example illustrates the core optimistic pattern:

1. **Snapshot** the previous value.
2. **Update state immediately** to the next value.
3. **Run the async request** in the background.
4. **Rollback** if the request fails.

We'll reuse this mental model in the rest of the post.

## Implementation Patterns

### 1. React Query / TanStack Query

[React Query](https://tanstack.com/query/latest) has first-class support for optimistic updates via `useMutation`.

```tsx showLineNumbers
import { useMutation, useQueryClient } from "@tanstack/react-query";

function useToggleTodo(id: string) {
	const queryClient = useQueryClient();

	return useMutation({
		mutationFn: async () => {
			// Call your API here
		},
		onMutate: async () => {
			await queryClient.cancelQueries({ queryKey: ["todos"] });

			// Snapshot previous value
			const previousTodos = queryClient.getQueryData<Todo[]>(["todos"]);

			// Optimistically update cache
			queryClient.setQueryData<Todo[]>(["todos"], (old = []) =>
				old.map((todo) =>
					todo.id === id ? { ...todo, completed: !todo.completed } : todo
				)
			);

			// Return context for rollback
			return { previousTodos };
		},
		onError: (_error, _variables, context) => {
			// Rollback to snapshot
			if (context?.previousTodos) {
				queryClient.setQueryData(["todos"], context.previousTodos);
			}
		},
		onSettled: () => {
			// Refetch to ensure server and client are in sync
			queryClient.invalidateQueries({ queryKey: ["todos"] });
		},
	});
}
```

This pattern is great when:

- Your data already lives in React Query.
- You want **automatic cache updates** and **refetch on settle**.
- You prefer colocating optimistic logic with mutations.

### 2. Custom "Optimistic Mutation" Hook

For non-React-Query setups, you can encapsulate the snapshot + optimistic update + rollback pattern in a custom hook.

```tsx showLineNumbers
import { useState } from "react";

type OptimisticConfig<T> = {
	getOptimisticValue: (current: T, input: T) => T;
	perform: (value: T) => Promise<void>;
};

export function useOptimisticValue<T>(initial: T, config: OptimisticConfig<T>) {
	const [value, setValue] = useState<T>(initial);
	const [isPending, setIsPending] = useState(false);
	const [error, setError] = useState<string | null>(null);

	async function update(nextInput: T) {
		if (isPending) return;

		setError(null);
		const previous = value;
		const optimistic = config.getOptimisticValue(value, nextInput);

		setValue(optimistic);
		setIsPending(true);

		try {
			await config.perform(optimistic);
		} catch (err) {
			setValue(previous);
			setError((err as Error).message);
		} finally {
			setIsPending(false);
		}
	}

	return { value, update, isPending, error } as const;
}
```

You can then reuse this hook for favorites, counters, toggles, and more by passing different `getOptimisticValue` and `perform` functions.

### 3. State Management Libraries

The same optimistic ideas apply in Zustand, Redux Toolkit, or Context:

- **Zustand**: perform an optimistic `set` in the store, and rollback on error using a snapshot.
- **Redux Toolkit / RTK Query**: use extra reducers or RTK Query's update utilities for optimistic cache updates.
- **Context**: keep shared state in context and expose helper methods that implement the optimistic pattern.

### 4. React 19's `useOptimistic` Hook

React 19 introduced a dedicated hook for optimistic state: [`useOptimistic`](https://react.dev/reference/react/useOptimistic).

```ts
const [optimisticState, addOptimistic] = useOptimistic(state, updateFn);
```

- `state`: the "real" state value.
- `updateFn(currentState, optimisticValue)`: a **pure function** that returns the optimistic state.
- `optimisticState`: equals `state` unless an update is pending.
- `addOptimistic(optimisticValue)`: triggers an optimistic update by calling `updateFn`.

A classic example is a message thread: when the user sends a message, you want it to appear immediately with a "Sending…" label.

```tsx showLineNumbers
import { useOptimistic, useState, useTransition } from "react";

function deliverMessage(message: string) {
	return new Promise<string>((resolve) => {
		setTimeout(() => resolve(message), 800);
	});
}

export function UseOptimisticThread() {
	const [messages, setMessages] = useState<
		{ text: string; sending?: boolean }[]
	>([{ text: "Hello there!", sending: false }]);
	const [isPending, startTransition] = useTransition();
	const [optimisticMessages, addOptimisticMessage] = useOptimistic(
		messages,
		(state, newMessage: string) => [
			{ text: newMessage, sending: true },
			...state,
		]
	);

	async function handleSend(formData: FormData) {
		const text = String(formData.get("message") || "").trim();
		if (!text) return;

		addOptimisticMessage(text);

		startTransition(async () => {
			const delivered = await deliverMessage(text);
			setMessages((current) => [
				{ text: delivered, sending: false },
				...current,
			]);
		});
	}

	return (
		<div className="space-y-3 text-sm">
			<form action={handleSend} className="flex items-center gap-2">
				<input
					name="message"
					placeholder="Say hi!"
					className="flex-1 rounded-md border bg-background px-2 py-1 text-xs md:text-sm"
				/>
				<button
					type="submit"
					disabled={isPending}
					className="rounded-md bg-primary px-3 py-1 text-xs md:text-sm text-primary-foreground disabled:opacity-60"
				>
					Send
				</button>
			</form>
			<div className="space-y-1">
				{optimisticMessages.map((message, index) => (
					<div key={index} className="text-xs md:text-sm">
						{message.text}
						{message.sending && (
							<span className="ml-1 text-[10px] text-muted-foreground">
								(Sending…)
							</span>
						)}
					</div>
				))}
			</div>
		</div>
	);
}
```

`useOptimistic` shines when you already use React Server Components or Server Actions and want optimistic UI without manually managing snapshots.

## Error Handling Strategies

Optimistic updates are only safe if you handle errors well.

### 1. Rollback Mechanisms

- **Snapshot pattern**: store the previous state before the optimistic change.
- **Inverse operation**: sometimes you can compute a rollback from the current state (e.g., toggling a boolean twice).
- **Undo UI**: instead of silently rolling back, let users explicitly undo.

### 2. Communicating Errors

- **Toasts** for transient issues ("Failed to like. Tap to retry").
- **Inline messaging** near the component when the context matters.
- **Retry buttons** when the action is important but not critical.

### 3. Edge Cases to Consider

- **Network failures**: offline, timeouts, flaky connections.
- **Server validation errors**: the server rejects invalid or stale data.
- **Race conditions**: multiple updates to the same entity at once.
- **Cross-device conflicts**: another device updates the same record.

Always ask: _what does the user see if this fails?_ and _can they recover?_

## Real-World Examples

### Social "Like" Button

- Optimistically toggle the like state and count.
- Rollback if the request fails.
- Optionally show a subtle error or toast.

### Todo Application

- Optimistically add a new todo to the list.
- Instantly strike-through when marking complete.
- Optimistically delete while providing an undo for a few seconds.

### Shopping Cart

- Optimistically add items to the cart badge.
- Update quantities immediately while syncing in the background.
- If a product goes out of stock, roll back and explain why.

## Best Practices & Common Pitfalls

### Do

- **Always** keep enough information to rollback.
- **Design for failure**: test with the network throttled and forced errors.
- **Show intent**: small "Saving…" or "Syncing…" labels can build trust.
- **Refetch or reconcile** after the server responds to avoid long-term drift.

### Don't

- Don't use optimistic updates for **irreversible, high-risk actions**.
- Don't hide errors completely—users should understand when something failed.
- Don't ignore **race conditions**; think about ordering and last-write-wins.

### Performance Considerations

Optimistic updates help **perceived** performance, but you should still:

- Avoid unnecessary re-renders (update minimal state, memoize where needed).
- Batch updates when possible.
- Measure using real devices and slow networks.

## Wrapping Up

Optimistic updates are one of the most effective ways to make your UI feel fast and alive:

- You **assume success** for common paths.
- You **handle failure gracefully** with rollbacks and clear messaging.
- You can implement them with plain React state, React Query, or React 19's `useOptimistic`.

Start small: pick a low-risk interaction like a like button or todo toggle, add an optimistic update, and observe how much better the app feels. Then extend the pattern to more flows where speed and responsiveness matter most.
